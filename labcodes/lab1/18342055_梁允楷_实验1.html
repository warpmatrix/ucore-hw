<!DOCTYPE html>
    <html>
    <head>
        <meta charset="UTF-8">
        <title>实验2 UCore启动过程-第2部分</title>
        <style>
</style>
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.css" integrity="sha384-yFRtMMDnQtDRO8rLpMIKrtPCD5jdktao2TV19YiZYWMDkUR5GQZR/NOVTdquEx1j" crossorigin="anonymous">
<link href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css" rel="stylesheet" type="text/css">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
<style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        <style>
.task-list-item { list-style-type: none; } .task-list-item-checkbox { margin-left: -20px; vertical-align: middle; }
</style>
        
        <script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script>
        
    </head>
    <body class="vscode-light">
        <!-- omit in toc -->
<h1 id="实验2-ucore启动过程-第2部分">实验2 UCore启动过程-第2部分</h1>
<!-- omit in toc -->
<h2 id="个人信息">个人信息</h2>
<table>
<thead>
<tr>
<th>院系专业</th>
<th>年级</th>
<th>姓名</th>
<th>学号</th>
</tr>
</thead>
<tbody>
<tr>
<td>软件工程</td>
<td>18级</td>
<td>梁允楷</td>
<td>18342055</td>
</tr>
</tbody>
</table>
<!-- omit in toc -->
<h2 id="table-of-contents">Table of Contents</h2>
<ul>
<li><a href="#%E7%BB%83%E4%B9%A03-%E5%88%86%E6%9E%90-bootloader-%E8%BF%9B%E5%85%A5%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%BF%87%E7%A8%8B">练习3 分析 bootloader 进入保护模式的过程</a></li>
<li><a href="#%E7%BB%83%E4%B9%A04-%E5%88%86%E6%9E%90-bootloader-%E5%8A%A0%E8%BD%BD-elf-%E6%A0%BC%E5%BC%8F%E7%9A%84-os-%E7%9A%84%E8%BF%87%E7%A8%8B">练习4 分析 bootloader 加载 ELF 格式的 OS 的过程</a>
<ul>
<li><a href="#bootloader-%E5%A6%82%E4%BD%95%E8%AF%BB%E5%8F%96%E7%A1%AC%E7%9B%98%E6%89%87%E5%8C%BA%E7%9A%84">bootloader 如何读取硬盘扇区的</a></li>
<li><a href="#bootloader-%E6%98%AF%E5%A6%82%E4%BD%95%E5%8A%A0%E8%BD%BD-elf-%E6%A0%BC%E5%BC%8F%E7%9A%84-os">bootloader 是如何加载 ELF 格式的 OS</a></li>
</ul>
</li>
<li><a href="#%E7%BB%83%E4%B9%A05-%E5%AE%9E%E7%8E%B0%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%A0%86%E6%A0%88%E8%B7%9F%E8%B8%AA%E5%87%BD%E6%95%B0">练习5 实现函数调用堆栈跟踪函数</a>
<ul>
<li><a href="#%E5%AE%9E%E7%8E%B0-print_stackframe-%E5%87%BD%E6%95%B0">实现 <code>print_stackframe</code> 函数</a></li>
<li><a href="#%E8%A7%A3%E9%87%8A%E6%9C%80%E5%90%8E%E4%B8%80%E8%A1%8C%E5%90%84%E4%B8%AA%E6%95%B0%E5%80%BC%E7%9A%84%E5%90%AB%E4%B9%89">解释最后一行各个数值的含义</a></li>
</ul>
</li>
<li><a href="#%E7%BB%83%E4%B9%A06-%E5%AE%8C%E5%96%84%E4%B8%AD%E6%96%AD%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E5%A4%84%E7%90%86">练习6 完善中断初始化和处理</a>
<ul>
<li><a href="#%E5%85%B3%E4%BA%8E%E4%B8%AD%E6%96%AD%E5%90%91%E9%87%8F%E8%A1%A8%E7%9A%84%E6%8F%8F%E8%BF%B0">关于中断向量表的描述</a></li>
<li><a href="#%E5%AF%B9%E4%B8%AD%E6%96%AD%E5%90%91%E9%87%8F%E8%A1%A8%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96">对中断向量表的初始化</a></li>
<li><a href="#%E5%AF%B9%E6%97%B6%E9%92%9F%E4%B8%AD%E6%96%AD%E9%83%A8%E5%88%86%E7%9A%84%E5%AE%8C%E5%96%84%E5%A4%84%E7%90%86">对时钟中断部分的完善处理</a></li>
</ul>
</li>
<li><a href="#%E6%89%A9%E5%B1%95%E7%BB%83%E4%B9%A0-%E5%AE%9E%E7%8E%B0%E5%86%85%E6%A0%B8%E6%80%81%E4%B8%8E%E7%94%A8%E6%88%B7%E6%80%81%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2">扩展练习 实现内核态与用户态相互转换</a></li>
<li><a href="#%E5%AE%9E%E9%AA%8C%E5%BF%83%E5%BE%97">实验心得</a></li>
<li><a href="#%E9%99%84%E5%BD%95">附录</a>
<ul>
<li><a href="#kerndebugkdebugc-%E4%B8%AD%E7%9A%84-print_stackframe-%E5%87%BD%E6%95%B0"><code>kern/debug/kdebug.c</code> 中的 <code>print_stackframe</code> 函数</a></li>
<li><a href="#kerntraptrapc-%E4%B8%AD%E7%9A%84-idt_init-%E5%87%BD%E6%95%B0"><code>kern/trap/trap.c</code> 中的 <code>idt_init</code> 函数</a></li>
<li><a href="#kerntraptrapc-%E4%B8%AD%E7%9A%84-trap_dispatch-%E5%87%BD%E6%95%B0%E6%97%B6%E9%92%9F%E4%B8%AD%E6%96%AD%E9%83%A8%E5%88%86"><code>kern/trap/trap.c</code> 中的 <code>trap_dispatch</code> 函数时钟中断部分</a></li>
<li><a href="#%E6%8B%93%E5%B1%95%E7%BB%83%E4%B9%A0%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81">拓展练习相关代码</a></li>
</ul>
</li>
</ul>
<!-- 文中使用到的锚点 -->
<h2 id="练习3-分析-bootloader-进入保护模式的过程">练习3 分析 bootloader 进入保护模式的过程</h2>
<blockquote>
<p>BIOS 将通过读取硬盘主引导扇区到内存,并转跳到对应内存中的位置执行 bootloader。请分析 bootloader 是如何完成从实模式进入保护模式的。</p>
</blockquote>
<p>CPU 从地址 0:0x7c00 以实模式进入主引导程序 <code>bootloader</code>，先执行 <code>boot/bootasm.S</code> 中的汇编指令。</p>
<ol>
<li>
<p>初始化环境</p>
<p>初始化环境包括了关中断、复位方向寄存器、清零寄存器等行为。</p>
<pre><code class="language-x86asm"><div><span class="hljs-meta">.code16</span>             # Assemble for <span class="hljs-number">16</span>-bit mode
    <span class="hljs-keyword">cli</span>             # Disable interrupts
    <span class="hljs-keyword">cld</span>             # String operations increment

    # Set <span class="hljs-meta">up</span> the important data <span class="hljs-meta">segment</span> registers (<span class="hljs-built_in">DS</span>, <span class="hljs-built_in">ES</span>, <span class="hljs-built_in">SS</span>).
    xorw %ax, %ax   # <span class="hljs-meta">Segment</span> number <span class="hljs-meta">zero</span>
    movw %ax, %ds   # -&gt; Data <span class="hljs-meta">Segment</span>
    movw %ax, %es   # -&gt; Extra <span class="hljs-meta">Segment</span>
    movw %ax, %ss   # -&gt; Stack <span class="hljs-meta">Segment</span>
</div></code></pre>
</li>
<li>
<p>打开 A20 Gate</p>
<p>由于实模式下，只提供 1MB 的可寻址空间，超过 1MB 的地址按 1MB 求模访问地址。为了访问更高位的地址，引入了 A20 Gate，也就是第 21 根地址线进行管理。一般开机时，默认关闭 A20 Gate，打开 A20 Gate后，方可实现更高位的寻址。</p>
<p>打开 A20 Gate，需要通过键盘控制器 8042，在其不繁忙的时候，先对 64h 端口发送 0xd1 指令，然后对 60h 发送 0xdf 指令。详细代码如下：</p>
<pre><code class="language-x86asm"><div><span class="hljs-symbol">seta20.1:</span>
    inb <span class="hljs-number">$0</span>x64, %al
    testb <span class="hljs-number">$0</span>x2, %al
    <span class="hljs-keyword">jnz</span> seta20<span class="hljs-meta">.1</span>

    movb <span class="hljs-number">$0</span>xd1, %al
    outb %al, <span class="hljs-number">$0</span>x64
<span class="hljs-symbol">
seta20.2:</span>
    inb <span class="hljs-number">$0</span>x64, %al
    testb <span class="hljs-number">$0</span>x2, %al
    <span class="hljs-keyword">jnz</span> seta20<span class="hljs-meta">.2</span>

    movb <span class="hljs-number">$0</span>xdf, %al
    outb %al, <span class="hljs-number">$0</span>x60
</div></code></pre>
</li>
<li>
<p>装载全局描述符表（GDT）</p>
<p>使用指令 <code>lgdt</code> 可以将 GDT 的入口地址加载到全局描述符表寄存器（GDTR）里，然后 CPU 就可以通过 GDTR 来访问 GDT。gdt 和 gdt 描述符在引导区也有相应的存储，可供直接装载。</p>
<pre><code class="language-x86asm"><div><span class="hljs-keyword">lgdt</span> gdtdesc

# omitted codes
<span class="hljs-symbol">
gdt:</span>
    SEG_NULLASM
    SEG_ASM(STA_X|STA_R, <span class="hljs-number">0x0</span>, <span class="hljs-number">0xffffffff</span>)
    SEG_ASM(STA_W, <span class="hljs-number">0x0</span>, <span class="hljs-number">0xffffffff</span>)
<span class="hljs-symbol">
gdtdesc:</span>
<span class="hljs-meta">    .word</span> <span class="hljs-number">0x17</span>
<span class="hljs-meta">    .long</span> gdt
</div></code></pre>
</li>
<li>
<p>设置 CR0 寄存器的保护位（PE）</p>
<p>CR0 寄存器的 0 号位 PE 是启用保护位（protection enable），将其置为 1，系统进入保护模式。</p>
<pre><code class="language-x86asm"><div><span class="hljs-meta">.set</span> CR0_PE_ON, <span class="hljs-number">0x1</span>     # protected mode enable flag

# omitted codes

    movl %cr0, %eax
    orl $CR0_PE_ON, %eax
    movl %eax, %cr0
</div></code></pre>
</li>
<li>
<p>初始化中断</p>
<p>接下来，通过长跳转更新 cs 寄存器的值，并且在保护模式下设置段寄存器的值，通过设置堆栈指针寄存器的值来建立堆栈。</p>
<pre><code class="language-x86asm"><div><span class="hljs-meta">.set</span> PROT_MODE_CSEG,        <span class="hljs-number">0x8</span>
<span class="hljs-meta">.set</span> PROT_MODE_DSEG,        <span class="hljs-number">0x10</span>

# omitted codes

    ljmp $PROT_MODE_CSEG, $protcseg
<span class="hljs-meta">
.code32</span>
<span class="hljs-symbol">protcseg:</span>
    movw $PROT_MODE_DSEG, %ax
    movw %ax, %ds
    movw %ax, %es
    movw %ax, %fs
    movw %ax, %gs
    movw %ax, %ss

    movl <span class="hljs-number">$0</span>x0, %ebp
    movl $start, %esp
</div></code></pre>
<p>然后，执行指令 <code>call bootmain</code> 进入 <code>bootloader</code> 的主方法。CPU加电启动时，<code>IDTR.base</code> 被初始化为 0，往后对中断向量表继续初始化的操作将在练习6继续讨论。</p>
</li>
</ol>
<h2 id="练习4-分析-bootloader-加载-elf-格式的-os-的过程">练习4 分析 bootloader 加载 ELF 格式的 OS 的过程</h2>
<blockquote>
<p>通过阅读 bootmain.c,了解 bootloader 如何加载 ELF 文件。通过分析源代码和通过 qemu 来运行并调试 bootloader &amp; OS。</p>
<ol>
<li>bootloader 如何读取硬盘扇区的?</li>
<li>bootloader 是如何加载 ELF 格式的 OS?</li>
</ol>
</blockquote>
<h3 id="bootloader-如何读取硬盘扇区的">bootloader 如何读取硬盘扇区的</h3>
<ol>
<li>
<p><code>readsect</code> 函数</p>
<p>我们可以在 <code>boot/bootmain.c</code> 第 43 行中找到函数 <code>readsect</code>，其作用是读取一个扇区内容。</p>
<p>从这个函数我们可以了解到要读入扇区的内容，首先要等待磁盘进入空闲状态。磁盘的状态可以通过 IO 地址寄存器 0x1f7（状态和命令寄存器）来获得，详见 <code>waitdisk</code> 函数：当 <code>inb(0x1f7) &amp; 0xc0 == 0x40</code> 时，磁盘进入空闲状态。</p>
<pre><code class="language-c"><div><span class="hljs-comment">/* waitdisk - wait for disk ready */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">waitdisk</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>{
    <span class="hljs-keyword">while</span> ((inb(<span class="hljs-number">0x1F7</span>) &amp; <span class="hljs-number">0xC0</span>) != <span class="hljs-number">0x40</span>)
        <span class="hljs-comment">/* do nothing */</span>;
}

<span class="hljs-comment">/* readsect - read a single sector at @secno into @dst */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">readsect</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *dst, <span class="hljs-keyword">uint32_t</span> secno)</span> </span>{
    <span class="hljs-comment">// wait for disk to be ready</span>
    waitdisk();
    <span class="hljs-comment">// ...</span>
</div></code></pre>
<p>指令 <code>outb(0x1F2, 1)</code> 用于表明读写的盘块数目为 1。接下来的 4 行代码，指明读取硬盘的扇区号，分别为：LBA 参数的 0-7 位、LBA 参数的 8-15 位、LBA 参数的 16-23 位和 LBA 参数的 24-27 位。剩余 0x1F6 的最高位用作指明当前通道的主从盘选择，0 为主盘，1 为从盘。</p>
<pre><code class="language-c"><div>outb(<span class="hljs-number">0x1F3</span>, secno &amp; <span class="hljs-number">0xFF</span>);
outb(<span class="hljs-number">0x1F4</span>, (secno &gt;&gt; <span class="hljs-number">8</span>) &amp; <span class="hljs-number">0xFF</span>);
outb(<span class="hljs-number">0x1F5</span>, (secno &gt;&gt; <span class="hljs-number">16</span>) &amp; <span class="hljs-number">0xFF</span>);
outb(<span class="hljs-number">0x1F6</span>, ((secno &gt;&gt; <span class="hljs-number">24</span>) &amp; <span class="hljs-number">0xF</span>) | <span class="hljs-number">0xE0</span>);
</div></code></pre>
<p>然后的指令 <code>outb(0x1F7, 0x20)</code> 给硬盘发送了读取命令，在硬盘空闲之后即可从 IO 地址 0x1f0 读取数据内容到 <code>dst</code> 中。</p>
<pre><code class="language-c"><div>outb(<span class="hljs-number">0x1F7</span>, <span class="hljs-number">0x20</span>);      <span class="hljs-comment">// cmd 0x20 - read sectors</span>
<span class="hljs-comment">// wait for disk to be ready</span>
waitdisk();
<span class="hljs-comment">// read a sector</span>
insl(<span class="hljs-number">0x1F0</span>, dst, SECTSIZE / <span class="hljs-number">4</span>);
</div></code></pre>
</li>
<li>
<p><code>readseg</code> 函数</p>
<p>我们能在 <code>boot/bootmain.c</code> 的第 63 行找到 <code>readseg</code> 函数。它是在 <code>readsect</code> 的基础上进行封装的函数，能读取硬盘任意长度的内容。</p>
<pre><code class="language-c"><div><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">readseg</span><span class="hljs-params">(<span class="hljs-keyword">uintptr_t</span> va, <span class="hljs-keyword">uint32_t</span> count, <span class="hljs-keyword">uint32_t</span> offset)</span> </span>{
    <span class="hljs-keyword">uintptr_t</span> end_va = va + count;

    <span class="hljs-comment">// round down to sector boundary</span>
    va -= offset % SECTSIZE;

    <span class="hljs-comment">// translate from bytes to sectors; kernel starts at sector 1</span>
    <span class="hljs-keyword">uint32_t</span> secno = (offset / SECTSIZE) + <span class="hljs-number">1</span>;

    <span class="hljs-comment">// If this is too slow, we could read lots of sectors at a time.</span>
    <span class="hljs-comment">// We'd write more to memory than asked, but it doesn't matter --</span>
    <span class="hljs-comment">// we load in increasing order.</span>
    <span class="hljs-keyword">for</span> (; va &lt; end_va; va += SECTSIZE, secno ++) {
        readsect((<span class="hljs-keyword">void</span> *)va, secno);
    }
}
</div></code></pre>
</li>
</ol>
<h3 id="bootloader-是如何加载-elf-格式的-os">bootloader 是如何加载 ELF 格式的 OS</h3>
<p><code>bootloader</code> 加载 ELF 格式的 OS，有如下的步骤：</p>
<ol>
<li>
<p>读取 ELF 文件的头部</p>
<p>上述的 <code>readseg</code> 函数可以读取任意位置任意大小的内容。我们借用这个函数读取 OS 镜像文件的第 1 页，大小为 8 个扇区，其中包含了 ELF 文件的头部信息。</p>
<pre><code class="language-c"><div><span class="hljs-comment">// read the 1st page off disk</span>
readseg((<span class="hljs-keyword">uintptr_t</span>)ELFHDR, SECTSIZE * <span class="hljs-number">8</span>, <span class="hljs-number">0</span>);
</div></code></pre>
</li>
<li>
<p>通过头部 <code>e_magic</code> 变量检查该 ELF 文件是否有效</p>
<p>若不是有效的 ELF 文件，则程序进行错误处理，并进入一个死循环：</p>
<pre><code class="language-c"><div><span class="hljs-comment">// is this a valid ELF?</span>
<span class="hljs-keyword">if</span> (ELFHDR-&gt;e_magic != ELF_MAGIC) {
    <span class="hljs-keyword">goto</span> bad;
}
<span class="hljs-comment">// omited codes</span>
bad:
    outw(<span class="hljs-number">0x8A00</span>, <span class="hljs-number">0x8A00</span>);
    outw(<span class="hljs-number">0x8A00</span>, <span class="hljs-number">0x8E00</span>);

    <span class="hljs-comment">/* do nothing */</span>
    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>);
</div></code></pre>
</li>
<li>
<p>加载 ELF 文件的程序段</p>
<p>通过 <code>elfheader</code> 提供的 <code>e_phoff</code> 和 <code>e_phnum</code> 获得 <code>program header table</code> 的起始地址和所其中包含的条目数量。</p>
<p>然后通过 <code>program header table</code> 可以访问各个 <code>program header</code>，从而读取各个程序段的内容。</p>
<pre><code class="language-c"><div><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proghdr</span> *<span class="hljs-title">ph</span>, *<span class="hljs-title">eph</span>;</span>

<span class="hljs-comment">// load each program segment (ignores ph flags)</span>
ph = (struct proghdr *)((<span class="hljs-keyword">uintptr_t</span>)ELFHDR + ELFHDR-&gt;e_phoff);
eph = ph + ELFHDR-&gt;e_phnum;
<span class="hljs-keyword">for</span> (; ph &lt; eph; ph ++) {
    readseg(ph-&gt;p_va &amp; <span class="hljs-number">0xFFFFFF</span>, ph-&gt;p_memsz, ph-&gt;p_offset);
}
</div></code></pre>
</li>
<li>
<p>执行 OS 内核</p>
<p>ELF 文件的头部信息中有执行内核的入口信息 <code>e_entry</code>，以此可以执行 OS 内核代码：</p>
<pre><code class="language-c"><div><span class="hljs-comment">// call the entry point from the ELF header</span>
<span class="hljs-comment">// note: does not return</span>
((<span class="hljs-keyword">void</span> (*)(<span class="hljs-keyword">void</span>))(ELFHDR-&gt;e_entry &amp; <span class="hljs-number">0xFFFFFF</span>))();
</div></code></pre>
</li>
</ol>
<h2 id="练习5-实现函数调用堆栈跟踪函数">练习5 实现函数调用堆栈跟踪函数</h2>
<blockquote>
<p>解释最后一行各个数值的含义。完成lab1编译后,查看 <code>lab1/obj/bootblock.asm</code>，了解 <code>bootloader</code> 源码与机器码的语句和地址等的对应关系；查看 <code>lab1/obj/kernel.asm</code>，了解 ucore OS 源码与机器码的语句和地址等的对应关系。</p>
<p>完成函数kern/debug/kdebug.c::print_stackframe的实现,提交改进后源代码包(可以编译执行),并在实验报告中简要说明实现过程,并写出对上述问题的回答。</p>
</blockquote>
<h3 id="实现-print_stackframe-函数">实现 <code>print_stackframe</code> 函数</h3>
<p>该函数按照项目所给的注释来进行操作，实现基本无问题。详细代码可参见 <a href="kern/debug/kdebug.c">kedebug.c</a>，或参见结尾附录 <a href="#kerndebugkdebugc-%E4%B8%AD%E7%9A%84-print_stackframe-%E5%87%BD%E6%95%B0">print_stackframe 函数实现</a>。程序的大致实现过程为：</p>
<ol>
<li>获得当前 ebp 和 eip 寄存器的值</li>
<li>进入循环：显示当前栈桢的相关信息，指令信息等内容</li>
<li>通过 <code>eip = *(uint32_t *)(ebp + 4)</code> 和 <code>ebp = *(uint32_t *)ebp</code> 两条指令更新 <code>eip</code> 和 <code>ebp</code>，获取上一个栈桢的信息</li>
<li>若获得足够的信息，则跳出循环；否则，返回步骤 2</li>
</ol>
<p>所得结果如下，与题目所给的例子大致相同：</p>
<p><img src="file:////home/warpmatrix/Projects/ucore_lab/labcodes/lab1/images/Ex5_output.png" alt="练习5 结果"></p>
<h3 id="解释最后一行各个数值的含义">解释最后一行各个数值的含义</h3>
<p>此处使用题目所提供的数据进行说明：</p>
<pre><code class="language-plaintext"><div>ebp:0x00007bf8 eip:0x00007d73 args:0xc031fcfa 0xc08ed88e 0x64e4d08e 0xfa7502a8
    &lt;unknow&gt;: -- 0x00007d72 –
</div></code></pre>
<p>在汇编语言中调用函数，需要进行恢复现场等一系列操作，为此，调用函数时，有一系列的规则，并引入 ebp 寄存器方便我们解决这一问题。</p>
<p>ebp 寄存器与 ss 段寄存器组合构成 <code>ss:ebp</code>。它指向的位置在堆栈中存储着主调函数的 ebp 的值。该 ebp 值的上方保存着主调函数的相关信息，如：<code>ss:ebp+4</code> 指向主调函数调用时的 eip，若被调函数需要使用参数则 <code>ss:ebp+8</code> 指向被调函数用到的第一个参数。该 ebp 值的下方保存着被调函数的相关信息，如局部变量等信息。</p>
<p>此处最后一行对应着堆栈的最深一层，即最初使用堆栈的函数 <code>bootmain</code>。在<a href="#%E7%BB%83%E4%B9%A03-%E5%88%86%E6%9E%90-bootloader-%E8%BF%9B%E5%85%A5%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%BF%87%E7%A8%8B">练习 3</a> 的步骤 5 处我们已经对 ebp 和 esp 寄存器进行了赋值，<code>bootmain</code> 函数所使用的堆栈结构位于 0:0x7c00 处。因此，记录了一次返回地址和一次 ebp 寄存器后，<code>bootmain</code> 函数所使用的栈桢的基址为 0x7bf8。调用函数的指令存储的位置为 0x7d73，由于bootmain 不需要使用参数，因此后面的参数：0xc031fcfa、0xc08ed88e、0x64e4d08e、0xfa7502a8 为无用参数。</p>
<h2 id="练习6-完善中断初始化和处理">练习6 完善中断初始化和处理</h2>
<blockquote>
<p>请完成编码工作和回答如下问题：</p>
<ol>
<li>中断向量表中一个表项占多少字节？其中哪几位代表中断处理代码的入口？</li>
<li>请编程完善 <code>kern/trap/trap.c</code> 中对中断向量表进行初始化的函数 <code>idt_init</code>。在 <code>idt_init</code> 函数中，依次对所有中断入口进行初始化。使用 <code>mmu.h</code> 中的 <code>SETGATE</code> 宏，填充 <code>idt</code> 数组内容。注意除了系统调用中断( <code>T_SYSCALL</code> )以外，其它中断均使用中断门描述符，权限为内核态权限;而系统调用中断使用异常，权限为陷阱门描述符。每个中断的入口由 <code>tools/vectors.c</code> 生成，使用 <code>trap.c</code> 中声明的 <code>vectors</code> 数组即可。</li>
<li>请编程完善 <code>trap.c</code> 中的中断处理函数 <code>trap</code>，在对时钟中断进行处理的部分填写 <code>trap</code> 函数中处理时钟中断的部分,使操作系统每遇到 100 次时钟中断后,调用 <code>print_ticks</code> 子程序，向屏幕上打印一行文字”100 ticks”。</li>
</ol>
<p>完成问题 2 和 3 要求的部分代码后，运行整个系统，可以看到大约每 1 秒会输出一次”100 ticks”，而按下的键也会在屏幕上显示。</p>
</blockquote>
<h3 id="关于中断向量表的描述">关于中断向量表的描述</h3>
<p>中断向量表（IDT）是一个 8 字节的描述符数组。因此，中断向量表一个表项占 8 字节。其中，第 16～47 位（共 32 位）表示中断处理代码的入口。</p>
<h3 id="对中断向量表的初始化">对中断向量表的初始化</h3>
<p>根据项目提供的注释，在 <code>kern/trap/vectors.S</code> 中提供了 <code>__vectors</code> 的相关定义。使用 <code>__vectors</code> 和宏函数 <code>SETGATE</code> 可以对中断向量表 <code>idt</code> 进行初始化。<code>SETGATE</code> 中的参数可以根据课件中给的提示进行设置。值得注意的是，<code>SETGATE</code> 中的 <code>sel</code> 参数需要在 <code>kern/mm/memlayout.h</code> 中找到全局代码段选择子对应的数值 <code>GD_KTEXT</code>。最后还要调用 <code>lidt</code> 指令，传递相应的基址和限制记录中断向量表的信息。详细代码可见结尾附录 <a href="#kerntraptrapc-%E4%B8%AD%E7%9A%84-idt_init-%E5%87%BD%E6%95%B0">idt_init 函数的实现</a>或 <a href="kern/trap/trap.c">trap.c</a> 文件。</p>
<blockquote>
<p>除了系统调用中断(T_SYSCALL)使用陷阱门描述符且权限为用户态权限以外,其它中断均使用特权级(DPL)为0的中断门描述符,权限为内核态权限。</p>
</blockquote>
<h3 id="对时钟中断部分的完善处理">对时钟中断部分的完善处理</h3>
<p>根据项目的注释，我们对时钟中断进行了自定义处理：每经历 100 次时钟中断，输出一次 <code>100 ticks</code>。代码比较简单，同样具体代码见详细代码可见结尾附录 <a href="#kerntraptrapc-%E4%B8%AD%E7%9A%84-trap_dispatch-%E5%87%BD%E6%95%B0%E6%97%B6%E9%92%9F%E4%B8%AD%E6%96%AD%E9%83%A8%E5%88%86">trap_dispatch 函数时钟中断部分的实现</a>或 <a href="kern/trap/trap.c">trap.c</a> 文件。</p>
<p><img src="file:////home/warpmatrix/Projects/ucore_lab/labcodes/lab1/images/Ex6_output.png" alt="练习6 结果"></p>
<h2 id="扩展练习-实现内核态与用户态相互转换">扩展练习 实现内核态与用户态相互转换</h2>
<blockquote>
<p>增加 syscall 功能,即增加一用户态函数(可执行一特定系统调用:获得时钟计数值),当内核初始完毕后,可从内核态返回到用户态的函数,而用户态的函数又通过系统调用得到内核态的服务。</p>
</blockquote>
<p>经过反复查阅网上资料，大致上了解实现用户态与内核态转换的方法。核心思想通过把所有的寄存器的值 <code>push</code> 入栈中，通过一个陷入帧对栈里保存的值进行修改。最后通过 <code>pop</code> 修改寄存器的值。实现对 <code>cs</code>、<code>ds</code>、<code>es</code>、<code>ss</code>、<code>eflags</code> 等寄存器的值进行修改，进入用户态/核心态。</p>
<p>详细代码参见<a href="#%E6%8B%93%E5%B1%95%E7%BB%83%E4%B9%A0%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81">附录</a>或者 <a href="kern/trap/trap.c">trap.c</a> 文件和 <a href="kern/init/init.c">init.c</a> 文件。</p>
<p><img src="file:////home/warpmatrix/Projects/ucore_lab/labcodes/lab1/images/challenge1_output.png" alt="拓展练习结果"></p>
<h2 id="实验心得">实验心得</h2>
<p>本次实验从机器启动到操作系统运行，逐步介绍整个系统运行的过程。从 BIOS 启动、bootloader 启动、最后到操作系统启动，初始化 gdt、idt 等。从第一条指令执行开始，对计算机系统有了更多深入的了解。期间深深的感受到 intel 由于历史包袱所带来深深的不便。为了前向兼容，intel 作出了相当多的设计，如：实模式、寄存器设计等。同时，通过对操作系统的引导，加强了多方面知识的学习。比如，对三种地址空间，反复进行回味；了解硬盘访问 LBA 模式是如何传参，进行对应功能的操作；如何对硬件直接编程也有了相应的了解。通过自主学习，也认识到内核态和用户态进行转换的大致思路。通过这次实验，了解了很多东西，也意识到操作系统的搭建是一个不断搭积木的过程，随着我们的零件逐渐增多，我们进行操作系统的搭建也慢慢容易起来。</p>
<h2 id="附录">附录</h2>
<h3 id="kerndebugkdebugc-中的-print_stackframe-函数"><code>kern/debug/kdebug.c</code> 中的 <code>print_stackframe</code> 函数</h3>
<pre><code class="language-c"><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print_stackframe</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>{
    <span class="hljs-keyword">uint32_t</span> ebp = read_ebp();
    <span class="hljs-keyword">uint32_t</span> eip = read_eip();
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; STACKFRAME_DEPTH; i++) {
        cprintf(<span class="hljs-string">"ebp:0x%08x eip:0x%08x "</span>, ebp, eip);
        <span class="hljs-keyword">uint32_t</span> *args = (<span class="hljs-keyword">uint32_t</span> *) ebp + <span class="hljs-number">2</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> ofst = <span class="hljs-number">0</span>; ofst &lt; <span class="hljs-number">4</span>; ofst++) {
            <span class="hljs-keyword">if</span> (ofst == <span class="hljs-number">0</span>) cprintf(<span class="hljs-string">"args:0x%08x"</span>, args[ofst]);
            <span class="hljs-keyword">else</span> cprintf(<span class="hljs-string">" 0x%08x"</span>, args[ofst]);
        }
        cprintf(<span class="hljs-string">"\n"</span>);
        print_debuginfo(eip - <span class="hljs-number">1</span>);
        eip = *(<span class="hljs-keyword">uint32_t</span> *)(ebp + <span class="hljs-number">4</span>);
        ebp = *(<span class="hljs-keyword">uint32_t</span> *)ebp;
    }
}
</div></code></pre>
<h3 id="kerntraptrapc-中的-idt_init-函数"><code>kern/trap/trap.c</code> 中的 <code>idt_init</code> 函数</h3>
<pre><code class="language-c"><div><span class="hljs-comment">/* idt_init - initialize IDT to each of the entry points in kern/trap/vectors.S */</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">idt_init</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>{
    <span class="hljs-keyword">extern</span> <span class="hljs-keyword">uintptr_t</span> __vectors[];
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">sizeof</span>(idt) / <span class="hljs-keyword">sizeof</span>(struct gatedesc); i++) {
        SETGATE(idt[i], <span class="hljs-number">0</span>, GD_KTEXT, __vectors[i], DPL_KERNEL);
    }
    SETGATE(idt[T_SYSCALL], <span class="hljs-number">1</span>, GD_KTEXT, __vectors[T_SYSCALL], DPL_USER);
    lidt(&amp;idt_pd);
}
</div></code></pre>
<h3 id="kerntraptrapc-中的-trap_dispatch-函数时钟中断部分"><code>kern/trap/trap.c</code> 中的 <code>trap_dispatch</code> 函数时钟中断部分</h3>
<pre><code class="language-c"><div><span class="hljs-keyword">case</span> IRQ_OFFSET + IRQ_TIMER:
    <span class="hljs-comment">/* LAB1 YOUR CODE : STEP 3 */</span>
    ticks++;
    <span class="hljs-keyword">if</span> (ticks % TICK_NUM == <span class="hljs-number">0</span>) {
        print_ticks();
    }
    <span class="hljs-keyword">break</span>;
</div></code></pre>
<h3 id="拓展练习相关代码">拓展练习相关代码</h3>
<ul>
<li>
<p><code>kern/init/init.c</code> 相关改动</p>
<p>在 <code>kern_init</code> 函数末尾增加一句：<code>lab1_switch_test();</code>。</p>
<p>完成函数 <code>lab1_switch_to_user</code> 和 <code>lab1_switch_to_kernel</code>：</p>
<pre><code class="language-c"><div><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span>
<span class="hljs-title">lab1_switch_to_user</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>{
    <span class="hljs-comment">//LAB1 CHALLENGE 1 : TODO</span>
    __asm__ __volatile__(
        <span class="hljs-string">"sub $8, %%esp\n"</span>
        <span class="hljs-string">"int %0\n"</span>
        <span class="hljs-string">"movl %%ebp, %%esp"</span>
        :
        : <span class="hljs-string">"i"</span>(T_SWITCH_TOU)
    );
}

<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span>
<span class="hljs-title">lab1_switch_to_kernel</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>{
    <span class="hljs-comment">//LAB1 CHALLENGE 1 :  TODO</span>
    __asm__ __volatile__(
        <span class="hljs-string">"int %0\n"</span>
        <span class="hljs-string">"movl %%ebp, %%esp"</span>
        :
        : <span class="hljs-string">"i"</span>(T_SWITCH_TOK)
    );
}
</div></code></pre>
</li>
<li>
<p><code>kern/trap/trap.c</code> 对 <code>trap_dispatch</code> 函数的改动</p>
<pre><code class="language-c"><div><span class="hljs-comment">//LAB1 CHALLENGE 1 : YOUR CODE you should modify below codes.</span>
<span class="hljs-keyword">case</span> T_SWITCH_TOU:
    tf-&gt;tf_cs = USER_CS;
    tf-&gt;tf_ds = USER_DS;
    tf-&gt;tf_es = USER_DS;
    tf-&gt;tf_ss = USER_DS;

    tf-&gt;tf_eflags |= FL_IOPL_MASK;
    <span class="hljs-keyword">break</span>;
<span class="hljs-keyword">case</span> T_SWITCH_TOK:
    tf-&gt;tf_cs = KERNEL_CS;
    tf-&gt;tf_ds = KERNEL_DS;
    tf-&gt;tf_es = KERNEL_DS;

    tf-&gt;tf_eflags &amp;= ~FL_IOPL_MASK;
    <span class="hljs-keyword">break</span>;
</div></code></pre>
</li>
</ul>

    </body>
    </html>